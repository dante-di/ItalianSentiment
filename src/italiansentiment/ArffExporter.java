/**
 * ARFF Exporter for WEKA
 *
 * LICENSE: To choose
 *
 * package: italianSentiment
 * author: Dario De Nart - Dante Degl'Innocenti
 * mail: deglinnocenti.dante@spes.uniud.it
 * copyright: Dario De Nart - Dante Degl'Innocenti
 *
 * 2015/02/17 - DDN - First Version
 */
package italiansentiment;

/**
 *
 * @author Dario De Nart
 */
import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.concurrent.ConcurrentNavigableMap;
import org.mapdb.DB;
import org.mapdb.DBMaker;

public class ArffExporter {

    private ArrayList<String> attributes;
    // attribute -> position number
    // useful for sparse ARFF files
    private HashMap<String, Integer> attributeKeys;
    // element key -> element classification
    private HashMap<Integer, String> classification;
    // elment key -> attributes map
    ConcurrentNavigableMap<Integer, HashMap<String, Double>> data;
    private Integer elementsCount;

    public ArffExporter() {
        DB db = DBMaker.newFileDB(new File("arffFilecache"))
                .closeOnJvmShutdown()
                .deleteFilesAfterClose()
                .transactionDisable()
                .make();
        attributes = new ArrayList<>();
        attributeKeys = new HashMap<>();
        classification = new HashMap<>();
        data = db.getTreeMap("data");
        elementsCount = 0;
    }
    
    // call this constructor if you want all attributes in the list to be displayed in the ARFF file
        public ArffExporter(List<String> attributes) {
        DB db = DBMaker.newFileDB(new File("arffFilecache"))
                .closeOnJvmShutdown()
                .deleteFilesAfterClose()
                .transactionDisable()
                .make();
        this.attributes = new ArrayList<>();
        this.attributes.addAll(attributes);
        attributeKeys = new HashMap<>();
        for(int i =0; i<attributes.size();i++){
            attributeKeys.put(attributes.get(i), i);
        }
        classification = new HashMap<>();
        data = db.getTreeMap("data");
        elementsCount = 0;
    }

    public void addElement(String label, HashMap<String, Double> attList) {
        data.put(elementsCount, attList);
        classification.put(elementsCount, label);
        elementsCount++;
        // now on with the attributes... Those bitches!
        for (String attribute : attList.keySet()) {
            if (!attributes.contains(attribute)) {
                attributeKeys.put(attribute, attributes.size());
                attributes.add(attribute);
            }
        }
    }

    // if you just don't want to bother with naming the attributes, just pass a vector and
    // attributes will be named according to their position
    public void addElement(String label, double[] attVector) {
        HashMap<String, Double> attList = new HashMap<>();
        for (int i = 0; i < attVector.length; i++) {
            if (attVector[i] != 0.0) {
                attList.put(Integer.toString(i), attVector[i]);
            }
        }
        addElement(label, attList);
    }

    public void writeArffFile(File destination) throws FileNotFoundException {
        writeArffFile(destination, false, true);
    }

    /**
     *
     * @param destination
     * @param unaryvalues
     * @param classValues
     * @throws FileNotFoundException
     */
    public void writeArffFile(File destination, Boolean unaryvalues, Boolean classValues) throws FileNotFoundException {
        // header
        String data = "% ARFF file generated by Linkerest\n\n@RELATION stereotype\n\n";

        //attribute section
        data += generateAttributesSection(classValues);

        //data section
        // our data must look like this
        /*
         @DATA
         5.1,3.5,1.4,0.2,Iris-setosa
         4.9,3.0,1.4,0.2,Iris-setosa
         4.7,3.2,1.3,0.2,Iris-setosa
         */
        data += "@DATA\n\n";
        // for each element
        for (Integer element : this.data.keySet()) {
            HashMap<String, Double> attList = this.data.get(element);
            // for each attribute

            for (String attribute : attributes) {
                if (attList.containsKey(attribute)) {
                    if (unaryvalues) {
                        data += "1,";
                    } else {
                        data += attList.get(attribute) + ",";
                    }
                } else {
                    data += "0,";
                }
            }
            // add classification
            if (classValues) {
                data += classification.get(element);
            }
            data += "\n";
        }
        //EOF line
        data += "\n";
        PrintWriter out = new PrintWriter(destination);
        out.write(data);
        out.close();
    }

    /**
     *
     * @param destination
     * @param unaryvalues
     * @param classValues
     * @throws FileNotFoundException
     */
    public void writeSparseArffFile(File destination, Boolean unaryvalues, Boolean classValues) throws FileNotFoundException {
        PrintWriter out = new PrintWriter(destination);
        // header
        out.write("% ARFF file generated by Linkerest\n\n@RELATION stereotype\n");

        //attribute section
        out.write(generateAttributesSection(classValues));

        //data section
        //data section
        // our data must look like this
        /*
         @ @data
         {1 X, 3 Y, 4 "class A"}
         {2 W, 4 "class B"}
         */
        out.write("@DATA\n\n");
        // for each element
        for (Integer element : this.data.keySet()) {
            String data = "";
            data += "{";
            HashMap<String, Double> attList = this.data.get(element);
            // for each attribute
            for (String attribute : attributes) {
                if (attList.containsKey(attribute)) {
                    if (unaryvalues) {
                        data += attributeKeys.get(attribute) + " 1, ";
                    } else {
                        data += attributeKeys.get(attribute) + " " + attList.get(attribute) + ", ";
                    }
                }
            }
            // add classification
            if (classValues) {
                data += attributes.size() + " \"" + classification.get(element) + "\"}";
            }
            data += "\n";
            out.write(data);
        }
        //EOF line
        out.write("\n");
        out.close();
    }

    private String generateAttributesSection(boolean classValues) {
        // we want to return something like this
        /*
         *    @ATTRIBUTE sepallength  NUMERIC
         @ATTRIBUTE sepalwidth   NUMERIC
         @ATTRIBUTE petallength  NUMERIC
         @ATTRIBUTE petalwidth   NUMERIC
         @ATTRIBUTE class        {Iris-setosa,Iris-versicolor,Iris-virginica}
         * 
         */
        String output = "";
        for (String attribute : attributes) {
            output += "@ATTRIBUTE " + attribute.replaceAll("'", "_").replaceAll("class", "clas") + "\t NUMERIC\n";
        }
        // now time to print the "class" attribute
        if (classValues) {
            output += "@ATTRIBUTE class {";
            String separator = "";
            HashSet<String> classes = new HashSet();
            classes.addAll(classification.values());
            for (String value : classes) {
                output += separator + value;
                separator = ",";
            }
            output += "}";
        }
        output += "\n\n";
        return output;
    }
}
